"""
VASP-specific functionality for the Multi-Agent DFT Research System.
"""

import os
import re
import logging
import numpy as np
from pathlib import Path

logger = logging.getLogger(__name__)

class VASPInterface:
    """Interface for generating VASP input files and analyzing VASP outputs."""
    
    def __init__(self, config=None):
        """
        Initialize the VASP interface with optional configuration.
        
        Args:
            config (dict, optional): Configuration parameters for VASP calculations.
        """
        self.config = config or {}
        self.default_config = {
            "SYSTEM": "VASP calculation",
            "ISTART": 0,
            "ICHARG": 2,
            "ENCUT": 400,
            "ISMEAR": 0,
            "SIGMA": 0.05,
            "IBRION": 2,
            "NSW": 100,
            "ISIF": 3,
            "EDIFF": 1.0e-5,
            "EDIFFG": -0.01,
            "PREC": "Accurate",
            "LWAVE": False,
            "LCHARG": True,
            "ALGO": "Normal",
            "NELM": 60,
            "NELMIN": 4
        }
        # KPOINTS default configuration
        self.default_kpoints = {
            "type": "gamma",
            "grid": [3, 3, 3],
            "shift": [0, 0, 0]
        }
        
    def get_config(self):
        """
        Get the effective configuration by merging default with user config.
        
        Returns:
            dict: Effective configuration.
        """
        effective_config = self.default_config.copy()
        effective_config.update(self.config)
        return effective_config
    
    def get_kpoints_config(self):
        """
        Get the effective KPOINTS configuration.
        
        Returns:
            dict: Effective KPOINTS configuration.
        """
        kpoints_config = self.default_kpoints.copy()
        if 'kpoints' in self.config:
            kpoints_config.update(self.config['kpoints'])
        return kpoints_config
    
    def generate_inputs(self, structure_data, output_dir, custom_config=None):
        """
        Generate all VASP input files from structure data.
        
        Args:
            structure_data (dict): Structure data with atom coordinates and metadata.
            output_dir (str or Path): Directory to save the input files.
            custom_config (dict, optional): Custom configuration for this specific job.
            
        Returns:
            bool: Success status.
        """
        # Merge configs
        config = self.get_config()
        if custom_config:
            config.update(custom_config)
        
        # Extract KPOINTS config
        kpoints_config = self.get_kpoints_config()
        if custom_config and 'kpoints' in custom_config:
            kpoints_config.update(custom_config['kpoints'])
        
        # Extract POTCAR settings
        potcar_dir = config.get('_potcar_dir')
        potcar_type = config.get('_potcar_type', 'PBE')
        
        # Generate and save input files
        return save_vasp_inputs(structure_data, output_dir, config, kpoints_config, potcar_dir)
    
    def parse_output(self, outcar_file, oszicar_file=None):
        """
        Parse VASP output files.
        
        Args:
            outcar_file (str or Path): Path to the OUTCAR file.
            oszicar_file (str or Path, optional): Path to the OSZICAR file.
            
        Returns:
            dict: Parsed output data.
        """
        return parse_vasp_output(outcar_file, oszicar_file)

def build_poscar(structure_data, config=None):
    """
    Build a VASP POSCAR file from structure data.
    
    Args:
        structure_data (dict): Structure data containing atomic coordinates and cell parameters.
        config (dict, optional): Additional configuration parameters.
    
    Returns:
        str: POSCAR file content.
    """
    if config is None:
        config = {}
    
    poscar_lines = []
    
    # Title line
    title = config.get('title', 'Generated by Multi-Agent DFT System')
    poscar_lines.append(title)
    
    # Scaling factor
    scaling = config.get('scaling', 1.0)
    poscar_lines.append(f"{scaling}")
    
    # Lattice vectors
    if 'cell' in structure_data:
        cell = structure_data['cell']
        for i in range(3):
            poscar_lines.append(f"{cell[i][0]:15.10f} {cell[i][1]:15.10f} {cell[i][2]:15.10f}")
    else:
        # Default to a 10x10x10 Ã… cubic cell
        poscar_lines.append("   10.0000000000    0.0000000000    0.0000000000")
        poscar_lines.append("    0.0000000000   10.0000000000    0.0000000000")
        poscar_lines.append("    0.0000000000    0.0000000000   10.0000000000")
    
    # Count atoms by element
    if 'atoms' not in structure_data:
        logger.error("No atoms in structure data")
        return ""
    
    atoms = structure_data['atoms']
    elements = {}
    for atom in atoms:
        symbol = atom['symbol']
        if symbol not in elements:
            elements[symbol] = []
        elements[symbol].append(atom['position'])
    
    # Element symbols line
    element_symbols = " ".join(elements.keys())
    poscar_lines.append(element_symbols)
    
    # Atom counts line
    atom_counts = " ".join(str(len(positions)) for positions in elements.values())
    poscar_lines.append(atom_counts)
    
    # Coordinate type
    coord_type = config.get('coord_type', 'Cartesian')
    poscar_lines.append(coord_type)
    
    # Atomic positions
    for element, positions in elements.items():
        for pos in positions:
            poscar_lines.append(f"{pos[0]:15.10f} {pos[1]:15.10f} {pos[2]:15.10f}")
    
    return "\n".join(poscar_lines)


def build_incar(config=None):
    """
    Build a VASP INCAR file from configuration.
    
    Args:
        config (dict, optional): INCAR configuration parameters.
    
    Returns:
        str: INCAR file content.
    """
    if config is None:
        config = {}
    
    # Default INCAR parameters for a typical DFT calculation
    default_params = {
        "SYSTEM": "VASP calculation",
        "ISTART": 0,        # Start from scratch
        "ICHARG": 2,        # Initial charge: from superposition of atomic charge densities
        "ENCUT": 400,       # Plane wave cutoff in eV
        "ISMEAR": 0,        # Gaussian smearing
        "SIGMA": 0.05,      # Width of smearing in eV
        "IBRION": 2,        # Conjugate gradient algorithm
        "NSW": 100,         # Maximum number of ionic steps
        "ISIF": 3,          # Calculate stress tensor, allow cell to change shape and volume
        "EDIFF": 1.0e-5,    # Electronic convergence
        "EDIFFG": -0.01,    # Ionic convergence (negative means forces)
        "PREC": "Accurate", # Precision
        "LWAVE": False,     # Don't write WAVECAR
        "LCHARG": True,     # Write CHGCAR
        "ALGO": "Normal",   # Electronic minimization algorithm
        "NELM": 60,         # Maximum number of electronic steps
        "NELMIN": 4,        # Minimum number of electronic steps
    }
    
    # Override defaults with user configuration
    params = default_params.copy()
    params.update(config)
    
    # Build INCAR file
    incar_lines = []
    for key, value in params.items():
        if isinstance(value, bool):
            value = ".TRUE." if value else ".FALSE."
        incar_lines.append(f"{key} = {value}")
    
    return "\n".join(incar_lines)


def build_kpoints(config=None):
    """
    Build a VASP KPOINTS file from configuration.
    
    Args:
        config (dict, optional): KPOINTS configuration parameters.
    
    Returns:
        str: KPOINTS file content.
    """
    if config is None:
        config = {}
    
    # Default KPOINTS parameters
    kpoint_type = config.get('type', 'auto')
    kpoint_lines = []
    
    # Comment line
    kpoint_lines.append("Automatic mesh")
    
    if kpoint_type.lower() == 'auto':
        # Automatic mesh
        kpoint_lines.append("0")
        kpoint_lines.append("Auto")
        kpoint_lines.append(str(config.get('grid_density', 40)))
    
    elif kpoint_type.lower() == 'gamma':
        # Gamma-centered mesh
        kpoint_lines.append("0")
        kpoint_lines.append("Gamma")
        kpoint_grid = config.get('grid', [3, 3, 3])
        kpoint_lines.append(f"{kpoint_grid[0]} {kpoint_grid[1]} {kpoint_grid[2]}")
        kpoint_shift = config.get('shift', [0, 0, 0])
        kpoint_lines.append(f"{kpoint_shift[0]} {kpoint_shift[1]} {kpoint_shift[2]}")
    
    elif kpoint_type.lower() == 'monkhorst':
        # Monkhorst-Pack mesh
        kpoint_lines.append("0")
        kpoint_lines.append("Monkhorst-Pack")
        kpoint_grid = config.get('grid', [3, 3, 3])
        kpoint_lines.append(f"{kpoint_grid[0]} {kpoint_grid[1]} {kpoint_grid[2]}")
        kpoint_shift = config.get('shift', [0, 0, 0])
        kpoint_lines.append(f"{kpoint_shift[0]} {kpoint_shift[1]} {kpoint_shift[2]}")
    
    elif kpoint_type.lower() == 'explicit':
        # Explicit kpoints
        kpoints = config.get('points', [])
        kpoint_lines.append(str(len(kpoints)))
        kpoint_lines.append("Cartesian" if config.get('cartesian', False) else "Reciprocal")
        for kpoint in kpoints:
            weight = kpoint[3] if len(kpoint) > 3 else 1.0
            kpoint_lines.append(f"{kpoint[0]} {kpoint[1]} {kpoint[2]} {weight}")
    
    return "\n".join(kpoint_lines)


def build_potcar(elements, potcar_dir=None, potcar_type='PBE'):
    """
    Build a VASP POTCAR file by concatenating element POTCARs.
    
    Args:
        elements (list): List of element symbols.
        potcar_dir (str, optional): Directory containing POTCAR files.
        potcar_type (str, optional): Type of POTCAR files (e.g., 'PBE', 'LDA').
    
    Returns:
        str or None: POTCAR file content if successful, None otherwise.
    """
    if potcar_dir is None:
        potcar_dir = os.environ.get('VASP_POTCAR_DIR', '')
    
    if not potcar_dir:
        logger.error("POTCAR directory not specified and VASP_POTCAR_DIR not set")
        return None
    
    potcar_dir = Path(potcar_dir)
    potcar_content = []
    
    for element in elements:
        element_dir = potcar_dir / f"{potcar_type}" / element
        potcar_file = element_dir / "POTCAR"
        
        if not potcar_file.exists():
            # Try alternative path
            potcar_file = potcar_dir / f"{element}_{potcar_type}" / "POTCAR"
        
        if not potcar_file.exists():
            # Try direct file
            potcar_file = potcar_dir / f"{element}_{potcar_type}"
        
        if not potcar_file.exists():
            logger.error(f"POTCAR for element {element} not found in {potcar_dir}")
            return None
        
        with open(potcar_file, 'r') as f:
            potcar_content.append(f.read())
    
    return "".join(potcar_content)


def save_vasp_inputs(structure_data, output_dir, incar_config=None, kpoints_config=None, potcar_dir=None):
    """
    Save all VASP input files for a calculation.
    
    Args:
        structure_data (dict): Structure data containing atomic coordinates and cell parameters.
        output_dir (str or Path): Directory to save the input files.
        incar_config (dict, optional): INCAR configuration parameters.
        kpoints_config (dict, optional): KPOINTS configuration parameters.
        potcar_dir (str, optional): Directory containing POTCAR files.
    
    Returns:
        bool: True if successful, False otherwise.
    """
    output_dir = Path(output_dir)
    output_dir.mkdir(parents=True, exist_ok=True)
    
    # Get unique element list
    elements = []
    if 'atoms' in structure_data:
        unique_elements = {atom['symbol'] for atom in structure_data['atoms']}
        elements = list(unique_elements)
    
    try:
        # Generate and save POSCAR
        poscar_content = build_poscar(structure_data)
        with open(output_dir / "POSCAR", 'w') as f:
            f.write(poscar_content)
        
        # Generate and save INCAR
        incar_content = build_incar(incar_config)
        with open(output_dir / "INCAR", 'w') as f:
            f.write(incar_content)
        
        # Generate and save KPOINTS
        kpoints_content = build_kpoints(kpoints_config)
        with open(output_dir / "KPOINTS", 'w') as f:
            f.write(kpoints_content)
        
        # Generate and save POTCAR if potcar_dir is specified
        if potcar_dir and elements:
            potcar_content = build_potcar(elements, potcar_dir)
            if potcar_content:
                with open(output_dir / "POTCAR", 'w') as f:
                    f.write(potcar_content)
            else:
                logger.warning("Could not generate POTCAR file")
        
        logger.info(f"VASP input files saved to {output_dir}")
        return True
    
    except Exception as e:
        logger.error(f"Error saving VASP input files: {e}")
        return False


def interactive_vasp_config():
    """
    Interactively ask the user for VASP parameters.
    
    Returns:
        tuple: (incar_config, kpoints_config) dictionaries.
    """
    incar_config = {}
    kpoints_config = {}
    
    print("\nPlease enter VASP parameters (press Enter to use defaults):")
    
    # INCAR parameters
    print("\n--- INCAR parameters ---")
    system = input("SYSTEM description (default 'VASP calculation'): ")
    if system:
        incar_config["SYSTEM"] = system
    
    encut = input("ENCUT (plane wave cutoff in eV, default 400): ")
    if encut:
        incar_config["ENCUT"] = float(encut)
    
    ibrion = input("IBRION (ionic relaxation algorithm, default 2 - conjugate gradient): ")
    if ibrion:
        incar_config["IBRION"] = int(ibrion)
    
    isif = input("ISIF (stress/relaxation control, default 3 - relax both ions and cell): ")
    if isif:
        incar_config["ISIF"] = int(isif)
    
    nsw = input("NSW (maximum number of ionic steps, default 100): ")
    if nsw:
        incar_config["NSW"] = int(nsw)
    
    ediff = input("EDIFF (electronic convergence criterion, default 1.0e-5): ")
    if ediff:
        incar_config["EDIFF"] = float(ediff)
    
    # Additional INCAR parameters
    print("\nDo you want to set additional INCAR parameters? (y/n, default n): ")
    if input().lower() == 'y':
        while True:
            param = input("Parameter name (or press Enter to finish): ")
            if not param:
                break
            
            value = input(f"Value for {param}: ")
            if value.upper() in [".TRUE.", ".FALSE."]:
                incar_config[param] = value.upper() == ".TRUE."
            elif value.replace('.', '', 1).replace('e', '', 1).replace('-', '', 1).isdigit():
                if '.' in value or 'e' in value.lower():
                    incar_config[param] = float(value)
                else:
                    incar_config[param] = int(value)
            else:
                incar_config[param] = value
    
    # KPOINTS parameters
    print("\n--- KPOINTS parameters ---")
    kpoint_type = input("KPOINTS type (auto/gamma/monkhorst/explicit, default auto): ")
    if kpoint_type:
        kpoints_config["type"] = kpoint_type.lower()
    else:
        kpoints_config["type"] = "auto"
    
    if kpoints_config["type"] == "auto":
        grid_density = input("Grid density (default 40): ")
        if grid_density:
            kpoints_config["grid_density"] = float(grid_density)
    
    elif kpoints_config["type"] in ["gamma", "monkhorst"]:
        grid = input("Grid (three integers separated by spaces, default '3 3 3'): ")
        if grid:
            kpoints_config["grid"] = [int(x) for x in grid.split()]
        else:
            kpoints_config["grid"] = [3, 3, 3]
        
        shift = input("Shift (three values separated by spaces, default '0 0 0'): ")
        if shift:
            kpoints_config["shift"] = [float(x) for x in shift.split()]
        else:
            kpoints_config["shift"] = [0, 0, 0]
    
    # POTCAR parameters (just gather info, actual generation happens elsewhere)
    print("\n--- POTCAR parameters ---")
    potcar_dir = input("POTCAR directory (press Enter to use VASP_POTCAR_DIR environment variable): ")
    potcar_type = input("POTCAR type (PBE/LDA, default PBE): ")
    if not potcar_type:
        potcar_type = "PBE"
    
    # Store POTCAR info in the incar_config dictionary
    if potcar_dir:
        incar_config["_potcar_dir"] = potcar_dir
    incar_config["_potcar_type"] = potcar_type
    
    return incar_config, kpoints_config


def parse_vasp_output(outcar_file, oszicar_file=None):
    """
    Parse VASP output files and extract key information.
    
    Args:
        outcar_file (str or Path): Path to the OUTCAR file.
        oszicar_file (str or Path, optional): Path to the OSZICAR file.
    
    Returns:
        dict: Extracted information from the output files.
    """
    result = {
        "energy": None,
        "converged": False,
        "errors": [],
        "warnings": [],
        "forces": [],
        "stress": [],
        "iterations": [],
        "magnetization": None
    }
    
    # Helper function to parse floating point values
    def parse_float(s):
        try:
            return float(s.strip())
        except ValueError:
            return None
    
    try:
        # Parse OUTCAR
        with open(outcar_file, 'r') as f:
            outcar = f.read()
        
        # Check for convergence
        if "reached required accuracy" in outcar:
            result["converged"] = True
        
        # Extract final energy
        energy_match = re.search(r"energy\(sigma->0\)\s+=\s+([-\d.]+)", outcar)
        if energy_match:
            result["energy"] = float(energy_match.group(1))
        
        # Extract forces
        force_blocks = re.findall(r"POSITION\s+TOTAL-FORCE.*?\n(.*?)(?:-{10}|\Z)", outcar, re.DOTALL)
        if force_blocks:
            last_force_block = force_blocks[-1].strip()
            forces = []
            for line in last_force_block.split('\n'):
                if line.strip():
                    parts = line.split()
                    if len(parts) >= 6:
                        forces.append([float(parts[3]), float(parts[4]), float(parts[5])])
            result["forces"] = forces
        
        # Extract stress tensor
        stress_match = re.search(r"in kB\s+([-\d.\s]+)", outcar)
        if stress_match:
            stress_line = stress_match.group(1).strip()
            stress_values = [float(x) for x in stress_line.split()]
            if len(stress_values) == 6:
                result["stress"] = stress_values
        
        # Extract magnetization if present
        mag_match = re.search(r"magnetization\s+=\s+([-\d.]+)", outcar)
        if mag_match:
            result["magnetization"] = float(mag_match.group(1))
        
        # Extract any errors or warnings
        error_matches = re.findall(r"ERROR:.*", outcar)
        for error in error_matches:
            result["errors"].append(error.strip())
        
        warning_matches = re.findall(r"WARNING:.*", outcar)
        for warning in warning_matches:
            result["warnings"].append(warning.strip())
        
        # Parse OSZICAR if provided
        if oszicar_file and os.path.exists(oszicar_file):
            with open(oszicar_file, 'r') as f:
                oszicar = f.read()
            
            # Extract iteration energies
            energy_lines = re.findall(r"DAV:.*E=\s+([-\d.]+).*\|", oszicar)
            result["iterations"] = [float(e) for e in energy_lines]
    
    except Exception as e:
        logger.error(f"Error parsing VASP output: {e}")
        result["errors"].append(str(e))
    
    return result